use std::collections::HashMap;
use std::error::Error;
use std::fs;
use std::path::Path;

extern crate toml;

const MAX_DEPTH: usize = 3;

fn main() -> Result<(), Box<dyn Error>> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <root_directory>", args[0]);
        std::process::exit(1);
    }
    let root_dir = Path::new(&args[1]);
    process_workspace(root_dir)?;
    Ok(())
}

/// Process the workspace by reading the root Cargo.toml, then finding subdirectories
/// (recursively up to MAX_DEPTH) containing their own Cargo.toml file, and writing a
/// cargo-workspace-docker.toml file in those directories if they declare workspace dependencies.
fn process_workspace(root_dir: &Path) -> Result<(), Box<dyn Error>> {
    // Parse root Cargo.toml to get dependency versions.
    let root_cargo_toml = root_dir.join("Cargo.toml");
    let root_toml_str = fs::read_to_string(&root_cargo_toml)?;
    let root_deps = parse_root_dependencies(&root_toml_str)?;

    process_workspace_recursive(root_dir, 0, &root_deps, root_dir)?;
    Ok(())
}

/// Recursively traverse subdirectories, up to MAX_DEPTH, to process each crate's Cargo.toml.
fn process_workspace_recursive(
    dir: &Path,
    depth: usize,
    root_deps: &HashMap<String, toml::Value>,
    root_dir: &Path,
) -> Result<(), Box<dyn Error>> {
    if depth >= MAX_DEPTH {
        return Ok(());
    }

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            let sub_cargo = path.join("Cargo.toml");
            if sub_cargo.exists() {
                let sub_toml = fs::read_to_string(&sub_cargo)?;
                let workspace_deps =
                    match find_workspace_dependencies(&sub_toml, root_deps, root_dir) {
                        Ok(v) => v,
                        Err(_) => continue,
                    };
                if !workspace_deps.is_empty() {
                    let docker_toml_path = path.join("cargo-workspace-docker.toml");
                    let content = generate_docker_toml(&workspace_deps);
                    fs::write(
                        docker_toml_path,
                        format!(
                            r#"# This file is generated by cargo-workspace-docker. Do not edit manually.
[workspace]
resolver = "2"
members = ["app"]
exclude = ["target"]

{content}"#
                        ),
                    )?;
                }
            }
            // Recursively process this subdirectory.
            process_workspace_recursive(&path, depth + 1, root_deps, root_dir)?;
        }
    }
    Ok(())
}

/// Parse the [dependencies] section from the root Cargo.toml,
/// returning a map of dependency names to their version strings.
fn parse_root_dependencies(toml_str: &str) -> Result<HashMap<String, toml::Value>, Box<dyn Error>> {
    let value: toml::Value = toml::from_str(toml_str)?;
    let dependencies = value
        .get("workspace")
        .and_then(|ws| ws.get("dependencies"))
        .and_then(|deps| deps.as_table())
        .ok_or("No [workspace.dependencies] section in root Cargo.toml")?;
    let mut map = HashMap::new();

    for (key, item) in dependencies {
        if let Some(version) = item.as_str() {
            let mut t = toml::value::Table::new();
            t.insert(
                "version".to_string(),
                toml::Value::String(version.to_string()),
            );
            map.insert(key.clone(), toml::Value::Table(t));
        } else if let Some(table) = item.as_table() {
            if table.contains_key("path") {
                // Transform to always use "./{crate}".
                let mut t = toml::value::Table::new();
                t.insert(
                    "path".to_string(),
                    toml::Value::String(format!("./{}", key)),
                );

                // insert original path if it exists

                if let Some(path) = table.get("path").and_then(|v| v.as_str()) {
                    t.insert(
                        "original_path".to_string(),
                        toml::Value::String(path.to_string()),
                    );
                }

                map.insert(key.clone(), toml::Value::Table(t));
            } else if let Some(version) = table.get("version").and_then(|v| v.as_str()) {
                let mut t = toml::value::Table::new();
                t.insert(
                    "version".to_string(),
                    toml::Value::String(version.to_string()),
                );
                map.insert(key.clone(), toml::Value::Table(t));
            }
        }
    }
    Ok(map)
}

/// Look for workspace dependencies in the subdirectory's Cargo.toml.
/// Returns a map of dependency names (that declare workspace = true) to their merged toml::Value.
fn find_workspace_dependencies(
    sub_toml_str: &str,
    root_deps: &HashMap<String, toml::Value>,
    root_dir: &Path,
) -> Result<HashMap<String, toml::Value>, Box<dyn Error>> {
    let value: toml::Value = toml::from_str(sub_toml_str)?;
    let dependencies = value
        .get("dependencies")
        .and_then(|deps| deps.as_table())
        .ok_or("No [dependencies] section in sub Cargo.toml")?;
    let mut map = HashMap::new();

    for (key, item) in dependencies {
        match item {
            toml::Value::Table(table) => {
                let mut new_table = toml::Table::new();
                if let Some(true) = table.get("workspace").and_then(|v| v.as_bool()) {
                    if let Some(root_val) = root_deps.get(key) {
                        if let toml::Value::Table(root_table) = root_val {
                            if root_table.contains_key("path") {
                                // Workspace dependency defined via a path in root.

                                let path_dep_cargo_toml = root_dir
                                    .join(
                                        root_table
                                            .get("original_path")
                                            .unwrap()
                                            .as_str()
                                            .unwrap()
                                            .replace("./", ""),
                                    )
                                    .join("Cargo.toml");

                                dbg!(&path_dep_cargo_toml);

                                new_table.insert(
                                    "path".to_string(),
                                    toml::Value::String(format!("./{}", key)),
                                );
                            } else if let Some(version) =
                                root_table.get("version").and_then(|v| v.as_str())
                            {
                                new_table.insert(
                                    "version".to_string(),
                                    toml::Value::String(version.to_string()),
                                );
                            }
                        }
                    }
                    new_table.extend(item.clone().as_table().unwrap().clone());
                    new_table.remove("workspace");
                }
                if !new_table.is_empty() {
                    map.insert(key.clone(), toml::Value::Table(new_table));
                }
            }
            _ => {
                // Copy non-table items directly.
                //map.insert(key.clone(), item.clone());
            }
        }
    }
    Ok(map)
}

/// Generates the content for cargo-workspace-docker.toml based on the workspace dependencies.
fn generate_docker_toml(deps: &HashMap<String, toml::Value>) -> String {
    // Create a table for dependencies
    let mut deps_table = toml::value::Table::new();
    for (key, value) in deps {
        deps_table.insert(key.clone(), value.clone());
    }
    // Nest the dependencies under the 'workspace' table
    let mut workspace_table = toml::value::Table::new();
    workspace_table.insert("dependencies".to_string(), toml::Value::Table(deps_table));
    let mut root_table = toml::value::Table::new();
    root_table.insert("workspace".to_string(), toml::Value::Table(workspace_table));
    // Serialize the object to a toml string
    toml::to_string(&root_table).expect("Failed to serialize toml")
}
